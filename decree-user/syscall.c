/*
 *  Linux syscalls
 *
 *  Copyright (c) 2003 Fabrice Bellard
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, see <http://www.gnu.org/licenses/>.
 */
#define _ATFILE_SOURCE
#include "qemu-common.h"
#include "qemu.h"


#define ERRNO_TABLE_SIZE 1200

/* target_to_host_errno_table[] is initialized from
 * host_to_target_errno_table[] in syscall_init(). */
static uint16_t target_to_host_errno_table[ERRNO_TABLE_SIZE] = {
};

/*
 * List of errno mappings for the errors that can be generated by the
 * set of valid DECREE syscalls.
 */
static uint16_t host_to_target_errno_table[ERRNO_TABLE_SIZE] = {
	[EAGAIN]       = TARGET_EAGAIN,
	[EBADF]        = TARGET_EBADF,
	[EFAULT]       = TARGET_EFAULT,
	[EINTR]        = TARGET_EINTR,
	[EINVAL]       = TARGET_EINVAL,
	[EIO]          = TARGET_EIO,
	[EISDIR]       = TARGET_EISDIR,
	[EDESTADDRREQ] = TARGET_EDESTADDRREQ,
	[EDQUOT]       = TARGET_EDQUOT,
	[EFBIG]        = TARGET_EFBIG,
	[ENOSPC]       = TARGET_ENOSPC,
	[EPIPE]        = TARGET_EPIPE,
	[ENOMEM]       = TARGET_ENOMEM,
	[ENODEV]       = TARGET_ENODEV,
	[EACCES]       = TARGET_EACCES,
	[ENFILE]       = TARGET_ENFILE,
	[EPERM]        = TARGET_EPERM,
	[ETXTBSY]      = TARGET_ETXTBSY,
	[EOVERFLOW]    = TARGET_EOVERFLOW
};

static inline int host_to_target_errno(int err)
{
    if(host_to_target_errno_table[err])
        return host_to_target_errno_table[err];
    return err;
}

static inline int target_to_host_errno(int err)
{
    if (target_to_host_errno_table[err])
        return target_to_host_errno_table[err];
    return err;
}

static inline abi_long get_errno(abi_long ret)
{
    if (ret == -1)
        return -host_to_target_errno(errno);
    else
        return ret;
}

static inline int is_error(abi_long ret)
{
    return (abi_ulong)ret >= (abi_ulong)(-4096);
}

char *target_strerror(int err)
{
    if ((err >= ERRNO_TABLE_SIZE) || (err < 0)) {
        return NULL;
    }
    return strerror(target_to_host_errno(err));
}

void syscall_init(void)
{
    int i;

    /* Build target_to_host_errno_table[] table from
     * host_to_target_errno_table[]. */
    for (i = 0; i < ERRNO_TABLE_SIZE; i++) {
        target_to_host_errno_table[host_to_target_errno_table[i]] = i;
    }
}

/* do_syscall() should always have a single exit point at the end so
   that actions, such as logging of syscall results, can be performed.
   All errnos that do_syscall() returns must be -TARGET_<errcode>. */
abi_long do_syscall(void *cpu_env, int num, abi_long arg1,
                    abi_long arg2, abi_long arg3, abi_long arg4,
                    abi_long arg5, abi_long arg6)
{
    /* CPUState *cpu = ENV_GET_CPU(cpu_env); */
    abi_long ret;
    void *p;

#ifdef DEBUG
    gemu_log("syscall %d", num);
#endif
    if(do_strace)
        print_syscall(num, arg1, arg2, arg3, arg4, arg5, arg6);

    switch(num) {
    case 1: /* terminate */
        _exit(arg1);
        ret = 0; /* avoid warning */
        break;

    case 2: /* transmit */
        if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))
            goto efault;
        ret = get_errno(write(arg1, p, arg3));
        if (!is_error(ret)) {
	        if (put_user_sal(ret, arg4))
		        goto efault;
	        ret = 0;
        }
        unlock_user(p, arg2, 0);
        break;

    case 3: /* receive */
	    if (arg3 == 0)
		    ret = 0;
	    else {
		    if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))
			    goto efault;
		    ret = get_errno(read(arg1, p, arg3));
		    if (!is_error(ret)) {
			    if (put_user_sal(ret, arg4))
				    goto efault;
			    ret = 0;
		    }
		    unlock_user(p, arg2, ret);
	    }
	    break;

    default:
        gemu_log("qemu: Unsupported syscall: %d\n", num);
        ret = -TARGET_ENOSYS;
        break;
    }
fail:
#ifdef DEBUG
    gemu_log(" = " TARGET_ABI_FMT_ld "\n", ret);
#endif
    if(do_strace)
        print_syscall_ret(num, ret);
    return ret;
efault:
    ret = -TARGET_EFAULT;
    goto fail;
}
